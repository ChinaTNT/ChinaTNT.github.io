<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>鸟哥的私房菜</title>
      <link href="/2020/01/18/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
      <url>/2020/01/18/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="CH0-计算机概论"><a href="#CH0-计算机概论" class="headerlink" title="CH0 计算机概论"></a>CH0 计算机概论</h1><ul><li><p>计算机组成单元</p><p>计算机组成：输入单元、处理单元（CPU内部控制单元+算术逻辑单元）、输出单元、存储单元（外部存储器+CPU内部的主存储器）。</p><p><code>数据都是流经CPU内部的主存储器在转出去的，至于数据会流进/流出内存则是CPU发出的控制命令实现，实际处理的数据完全来自主存储器</code></p></li><li><p>CPU种类</p><ol><li><p>精简指令集(Reduced Instruction Set Computing, RISC)</p><p>完成动作单一，执行时间短</p><p><em>常见的RISC 微指令集 CPU 例如Sun公司的 SPARC 系列、 IBM 公司的Power Architecture(包括 PowerPC)系列、不 ARM 系 列等</em></p></li><li><p>复杂指令集(Complex Instruction Set Computer, CISC)</p><p>每个指令集成了一些较低阶的硬件操作，指令数目多且杂，执行时间较长，处理的工作较为丰富。</p><p><em>Intel/AMD 的x86 架构CPU</em></p></li></ol><p><code>指令集：软件都经过CPU内部转换成微指令来执行</code></p><p><img src="%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%BE%E4%BE%8B.png" alt="微指令集"></p></li><li><p>接口设备</p><p>最重要的接口设备–主板（负责将所有设备通通连一起）</p><p>主板最重要的组件–主板芯片组（将所有设备汇集一起）</p><p>芯片组分两个网桥与各组件交互</p><ol><li>北桥：负责速度快的组件，CPU、主存储器、显示适配器等组件</li><li>南桥：负责连接速度较慢的组件，硬盘、USB、网卡等 </li></ol><p>次要设备–存储设备、显示设备、网络设备（网卡）</p></li><li><p>容量单位</p><table><thead><tr><th>进制位</th><th>K</th><th>M</th><th>G</th><th>T</th><th>P</th></tr></thead><tbody><tr><td>二进制</td><td>1024</td><td>1024K</td><td>1024M</td><td>1024G</td><td>1024T</td></tr><tr><td>十进制</td><td>1000</td><td>1000K</td><td>1000M</td><td>1000G</td><td>1000T</td></tr></tbody></table></li><li><p>速度单位</p><p>CPU指令周期常用单位MHz或GHz，Hz其实是秒分之一。</p><p><em>CPU主频为3Ghz表示1秒能进行3x10^9次工作（一次工作运行少数的指令），若外频为333Mhz，则倍频为9倍。3G = 333M x 9</em></p><ul><li><p>外频（通常超频是指拉高外频）</p><p>是指CPU与外部组件进行数据传输时的速度</p></li><li><p>倍频（通常被厂家锁定，无法修改）</p><p>是指CPU内部用来加速工作效能的一个倍数</p><p><code>主频 = 外频 x 倍频</code></p></li></ul><p>网络使用单位为Mbps（Mbit per second）</p><p><em>8M ADSL –&gt; 1Mbyte/s</em></p><p><em>1M ADSL –&gt; 125Kbyte/s</em></p></li><li><p>带宽</p><p>北桥支持的频率称为前端总线速度（Front Side Bus，FSB）（通常为内存频率1066/1333/1600Mhz），每次传送数据的位数为总线宽度。常见的总线宽度为32bit/64bit。</p><p>举例：内存与北桥的带宽为12.8GBytes/s </p><p>即1600Mhz x 64bits = 1600Mhz x 8Bytes = 12800MBytes/s = 12.8GBytes/s </p></li><li><p>内存</p><p>主存储器（内存）主要组件为动态随机存取内存（dynamic random access memory，DRAM）<code>需在通电状态使用，断电数据丢失，也称为这种RAM为挥发行内存</code></p><ul><li><p>DRAM 技术更新分好几代（由旧到新）</p><ul><li><p>SDRAM</p></li><li><p>DDR SDRAM（DDR、DDRⅡ、DDRⅢ、DDR4）</p><p>DDR 是指双倍数据传送（Double Data Rate，一个工作周期进行两次数据传送，类似CPU倍频）</p></li></ul></li></ul><img src="DDR型号.png" alt="DDR型号" style="zoom:100%;" /></li><li><p>双通道设计</p><p>拓展传统总线的宽度，将两个内存汇总在一起以达到128bit，就是双通道的设计理念。</p></li><li><p>DRAM与SRAM(Static Random Access Memory,SRAM)</p><p><img src="SRAM%E9%9D%99%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%86%85%E5%AD%98.png" alt="SRAM"></p><p>L2 cache就是静态随机存储内存，SRAM在设计上使用晶体管数量较多，价格高不易做成大容量，但其速度快，因此整合到CPU成为高速缓存。</p></li><li><p>只读存储器ROM</p><p>BIOS（basic input output system）是系统开机首先会去读取的小程序，控制着开机时各项硬件参数，CMOS将记录这些参数到ROM中，这些参数包括系统时间、CPU电压与频率、各项设备的IO地址、IRQ中断信道等。</p><p><em>记录需要用电，所以主板上还有个小电池专门用来供电，断电数据不会丢失</em></p></li><li><p>闪存flash和EEPROM</p><p>现在BIOS也需要更新，而ROM又是无法修改的，所以现在BIOS通常写入闪存flash和EEPROM中。</p></li><li><p>固态硬盘SSD（solid state disk）</p><p>厂商用闪存做的，数据延迟低、省电、寿命较机械硬盘短。</p></li><li><p>显卡插槽</p><p><img src="PCI-Express.png" alt=""></p><p><img src="PCIe.png" alt="PCIe"></p></li><li><p>操作系统</p><p>简单理解为核心和相关的用户应用软件。只管理整个硬件资源（CPU、内存、输入输出装置及文件系统文件。）</p><p><em>如果没有用户软件的辅助，操作系统只能让计算机Ready而已</em></p></li><li><p>驱动程序</p><p>驱动硬件在操作系统上正常运行。驱动程序由厂商提供，与操作系统开发者无关。</p></li><li><p>应用程序</p><p>依托操作系统提供的开发接口所开发出来的软件。</p></li></ul><h1 id="CH1-Linux是什么"><a href="#CH1-Linux是什么" class="headerlink" title="CH1 Linux是什么"></a>CH1 Linux是什么</h1><ol><li><p>Linux的历史</p><p>Linus Torvalds开发Linux核心</p><p>POSIX（Portable Operating System Interface）可携式操作系统接口</p><p>树莓派/香蕉派/智能型手机/平板的ARM架构系统大多也使用Linux核心</p></li><li><p>Linux是架站首选（具备计算机基础和网络基础相关知识）</p></li><li><p>网络服务问题，到/var/log/目录中查询log file文件解决</p></li><li><p>设备在linux中以文件的形式存在，常用设备如下表</p></li></ol><table><thead><tr><th>设备</th><th>路径</th></tr></thead><tbody><tr><td>SCSI/SATA/USB硬盘机</td><td>/dev/sd[a-p]</td></tr><tr><td>USB闪存盘</td><td>/dev/sd[a-p]（与SATA相同）</td></tr><tr><td>VirtI/O界面</td><td>/dev/vd[a-p]</td></tr><tr><td>25针打印机</td><td>/dev/lp[0-2]</td></tr><tr><td>USB接口打印机</td><td>/dev/lp[0-15]</td></tr><tr><td>通用鼠标</td><td>/dev/input/mouse[0-15]</td></tr><tr><td>PS/2界面鼠标</td><td>/dev/mouse</td></tr><tr><td>当前鼠标</td><td>/dev/mouse</td></tr><tr><td>CDROM/DVDROM</td><td>/dev/scd[0-1]</td></tr></tbody></table><p>​    </p><h1 id="CH2-主机规划与磁盘分区"><a href="#CH2-主机规划与磁盘分区" class="headerlink" title="CH2 主机规划与磁盘分区"></a>CH2 主机规划与磁盘分区</h1><p>磁盘分区演进：MBR -&gt; GPT</p><img src="磁盘分区表的作用示意图.png" style="" alt="DDR型号" style="zoom:100%;">   <p>所谓分区是针对64 Bytes进行分区设置，默认的分区表仅能写入四组分区信息，这四个分区的记录被称为主要（Primary）或延伸（Extended）分区。延伸分区最多只能有一个且不能被格式化（操作系统限制，当然可以没有延伸分区）。</p><p>分区的最小单位“通常”为柱面。</p><p>超过四个区是通过延伸分区的方式处理。分出的区域为逻辑分区。</p><p><img src="%E5%88%86%E5%8C%BA%E5%9B%9B%E4%B8%AA%E4%BB%A5%E4%B8%8A.png" alt=""></p><p><img src="%E5%88%86%E5%8C%BA%E4%BE%8B%E9%A2%98.png" alt=""></p><p><img src="%E5%88%86%E5%8C%BA%E4%BE%8B%E9%A2%98%E7%AD%94%E6%A1%88.png" alt=""></p><p><img src="%E5%88%86%E5%8C%BA%E4%BE%8B%E9%A2%982.png" alt=""></p><p><img src="%E5%88%86%E5%8C%BA%E4%BE%8B%E9%A2%982%E7%AD%94%E6%A1%88.png" alt=""></p><p>GPT分区已经没有延伸分区与逻辑分区的概念，你可以想象所有分区都是主分区。</p><p><img src="GPT%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%84.png" alt=""></p><p>开机流程</p><p><strong>BIOS -&gt; MBR -&gt; boot loader -&gt; 核心文件 -&gt; 操作系统</strong></p><ol><li>BIOS：开机主动执行的固件，会认识第一个可开机的设备；</li><li>MBR：第一个可开机设备的第一个扇区内的主要开机记录区块，内含开机管理程序。</li><li>开机管理程序（boot loader）：一支可读取核心文件来执行的软件；<ul><li>提供菜单：使用者可以选择不同的开机项目，这也是多重开机的重要功能。</li><li>载入核心文件：直接指向可开机的程序区段来开始操作系统。</li><li>转交其他loader：将开机管理功能转交给其他loader负责。</li></ul></li><li>核心文件：开始操作系统的功能…</li></ol><p>UEFI与BIOS</p><p>文件系统与目录数的关系</p><p>挂载：利用一个目录当成进入点，将磁盘分区的数据放置在该目录下。</p><h1 id="CH3-安装CentOS-7-x"><a href="#CH3-安装CentOS-7-x" class="headerlink" title="CH3 安装CentOS 7.x"></a>CH3 安装CentOS 7.x</h1><p>swap：磁盘仿真成为内存，由于swap并不会使用目录树的挂载，所以用sawp就不需要指定挂载点。</p><p>xfs：CentOS默认的文件系统。</p><h1 id="CH4-首次登陆与线上求助"><a href="#CH4-首次登陆与线上求助" class="headerlink" title="CH4 首次登陆与线上求助"></a>CH4 首次登陆与线上求助</h1><p><img src="%E8%AF%AD%E7%B3%BB%E4%BF%AE%E6%94%B9.png" alt=""></p><p>基础指令操作</p><p><img src="%E7%AE%80%E5%8D%95%E7%9A%84%E5%91%BD%E4%BB%A4.png" alt=""></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E6%95%B0%E9%99%A4%E6%B3%95.png" alt=""></p><p>Ctrl+d 代表exit</p><p>Shift+Page Up 代表向前翻页</p><p>Shift+Page Down 代表向后翻页</p><p>man</p><p>​        是manual（操作说明的简写）</p><p>​        man date将输出以下信息，<em>在此页面中输入 /abc ，可以对abc进行向下查找，输入？abc，可以对abc进行向上搜索，搜索后按n进行向下搜索，按N进行向上搜索</em>。</p><p>​        ![](man date.png)</p><p>括号中1的含义：(<code>表中1，5，8三个号码特别重要，必须熟记</code>)</p><p><img src="man%E4%B8%AD1%E7%9A%84%E5%90%AB%E4%B9%89.png" alt=""></p><p>超简单文本编辑器 – nano</p><p>nano text.txt#打开一text.txt文件</p><p><img src="nano%E6%8C%87%E4%BB%A4.png" alt=""></p><p>按Ctrl+G或F1 能调出详细说明</p><p><img src="nano%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E.png" alt=""></p><p>正确的关机指令使用</p><ul><li>将数据同步写入硬盘中的指令 sync</li><li>惯用的关机指令 shutdown</li><li>重新开机，关机 reboot，halt，poweroff</li></ul><p><img src="shutdown%E8%AF%B4%E6%98%8E.png" alt=""></p><h1 id="CH5-Linux的文件权限与目录配置"><a href="#CH5-Linux的文件权限与目录配置" class="headerlink" title="CH5 Linux的文件权限与目录配置"></a>CH5 Linux的文件权限与目录配置</h1><p>Linux一般将文件的身份分为三个类别：owner/group/others</p><p>这三种身份均拥有三种权限：read/write/execute</p><p><img src="%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><p><img src="%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90.png" alt=""></p><p><img src="%E6%9D%83%E9%99%90%E4%BE%8B%E9%A2%981.png" alt=""></p><p><code>root不受权限的限制，默认root都能访问，即使权限为---------</code></p><p>改变文件属性与权限</p><ul><li><p>chgrp 改变文件所属群组</p><pre><code class="shell">chgrp users file.txt如果连同目录下的所有次目录或者文件同时更改文件拥有者的话，直接加上-R的选项即可 </code></pre></li><li><p>chown 改变文件拥有者</p><pre><code class="shell">chown [-R] 用户拥有者 文件或目录chown [-R] 用户拥有者：群组名称 文件或目录如果连同目录下的所有次目录或者文件同时更改文件拥有者的话，直接加上-R的选项即可 </code></pre></li></ul><ul><li><p>chmod 改变文件的权限，SUID,SGID,SBIT等等特性</p><ul><li><p>各权限分数对照表</p><p>r：4</p><p>w：2</p><p>x：1</p><p>eg  -rwx rwx —</p><p>​        owner = rwx = 4+2+1=7</p><p>​        group = rwx = 4+2+1=7</p><p>​        others = — = 0+0+0=0</p><pre><code>chmod 644 .bashrc</code></pre></li><li><p>符号类型改变文件权限</p><p><img src="%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png" alt=""></p><pre><code>#设置权限-rwxr-xr-xchmod u=rwx,go=rx .bashrc #注 中间没有空白#设置权限-rwxr-xr--chmod u=rwx,g=rx,o=r .bashrc#给每个人增加写入权限chmod a+w .bashrc#去掉每个人的写入权限chmod a-w .bashrc #注 去掉不存在的权限不会报错</code></pre></li></ul></li><li><p>权限对目录的重要性</p><p>上述权限只针对文件属性，而并不具备删除文件本身的权限</p><p>目录中rwx的重新定义</p><ul><li><p>r （read contents in directory）</p><p>表示可以查看目录的文件名，用ls可以将其显示出来</p></li><li><p>w （modify contents of diectory）</p><p>你拥有以下权限</p><ul><li>创建新的文件和目录</li><li>删除已经存在的文件和目录</li><li>将已存在的文件或目录更名</li><li>搬移该目录内的文件、目录位置</li></ul></li><li><p>x （access directory）</p><p>与执行文件不同，目录x代表的是使用者能否进入该目录成为工作目录。而切换目录的命令为cd，所以没有x，你cd不进去这个目录。</p></li></ul><p><img src="%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E6%B1%87%E6%80%BB.png" alt="&quot;文件和目录权限异同&quot;"></p><p>说明：</p><p>我们看到root目录下，用户权限为rwx，却无法删除文件，就是因为它不是目录的拥有者。</p><p>所以，tnt用户删除不了该目录中任何一个文件</p><pre><code>drwxr-xr-x  1 root root    512 Jan 26 22:06 bin#可以删除自身目录下的文件，因为该目录用户拥有w权限 tnt@TNT-PC:~$ pwd/home/tnttnt@TNT-PC:~$ ls -ltotal 497788-rwxr-xr-x 1 root root      5047 Jan 26 22:08 znew</code></pre><p><img src="%E6%9D%83%E9%99%90%E7%90%86%E8%A7%A3%E8%A1%A81.png" alt=""></p><p>表格解析：其实r是非必备的，相当摸黑你也能操作文件夹，如上图表格表格中最后一个权限。但没有r的话，你的TAB不能补齐哦。</p><p>所以，通常开放的目录会具备rx这两个权限。而w涉及删除操作，需谨慎对待。</p></li></ul><ul><li><p>常规文件 regular file</p><ul><li><p>纯文本文件 </p><p>可以用cat读出来</p></li><li><p>二进制文件</p><p>可执行文件，例如cat本身就是个二进制文件</p></li><li><p>数据格式文件</p><p>它属于特殊格式的文件，可以用last命令读出来</p><p><img src="%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6.png" alt=""></p></li><li><p>目录</p></li><li><p>链接文件</p><p>类似快捷方式</p></li><li><p>设备与设备文件</p><ul><li>区块block设备文件 硬盘、软盘等</li><li>字符character设备文件 键盘、鼠标等</li></ul></li><li><p>数据接口文件 sockets</p><p>可通过sockets进行通信</p></li><li><p>管道文件（FIFO， pipe）</p></li></ul></li><li><p>具备可执行权限不一定具备可执行的程序码，只有两者均具备的文件才能被执行。Linux的文件没有所谓的“扩展名”。</p></li></ul><p>Linux文件名称限制</p><p>​        最好避免以下一些特殊字符比较好：</p><pre><code>*? &gt; &lt; ; &amp; ! [ ] | \ &#39; &quot; &quot; &#39; ( ) { } . - + </code></pre><p>Linux目录配置的依据 – FHS</p><ul><li><p>/ （ root, 根目录） ： 与开机系统有关；</p></li><li><p>/usr （ unix software resource） ： 与软件安装/执行有关；</p></li><li><p>/var （ variable） ： 与系统运行过程有关 。</p></li><li><p>FHS标准建议</p><p>根目录所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但性能较佳，也不容易发生问题。</p></li></ul><p><img src="FHS%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%951.png" alt=""></p><p><img src="FHS%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%952.png" alt=""></p><p><img src="FHS%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%953.png" alt=""></p><p><img src="FHS%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%954.png" alt=""></p><p><img src="FHS%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%955.png" alt=""></p><p><img src="%E7%9B%AE%E5%BD%95%E6%A0%91%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h1 id="CH6-Linux文件与目录管理"><a href="#CH6-Linux文件与目录管理" class="headerlink" title="CH6 Linux文件与目录管理"></a>CH6 Linux文件与目录管理</h1><p>shell scripts建议使用绝对路径</p><pre><code>.             代表此层目录..             代表上一层目录-             代表上一次访问的目录~             代表“目前使用身份”所在的主文件夹~account     代表account这个使用者所在的主文件夹</code></pre><p>cd </p><p>cd - 切换到上一次访问的工作目录</p><p>pwd 是Print Working Directory的缩写，显示当前目录（若是链接目录，显示的是链接目录而非实际目录）</p><p>pwd -P 与pwd区别在于，-P表示的是实际目录，而非链接目录</p><p>mkdir</p><pre><code>-m 设置文件夹的权限mkdir -m 711 test-p 递归创建目录mkdir -p test1/test2/test3/test</code></pre><p>echo $PATH 显示环境变量</p><p>PATH =”${PATH}:/root” 添加环境变量</p><p>不建议将“.”加入PATH的搜索目录中</p><p>文件与目录管理</p><ul><li><p>ls</p><p><img src="ls.png" alt=""></p><pre><code>modification time （ mtime）：文件内容变更会对该时间进行更新。status time （ ctime） ：权限或属性改变会更新此时间access time （ atime） ：文件被读取会更新此时间egdate; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \&gt; ls -l --time=ctime /etc/man_db.conf</code></pre></li></ul><ul><li><p>复制、移动、删除：cp，rm，mv</p><p>cp</p><p><img src="cp.png" alt=""></p><p><code>默认条件下，cp的来源文件与目标文件的权限是不同的，目标文件的拥有者通常会是指令操作者本身，需要和来源文件一致，可以使用-a或是-p选项</code>    </p><p><img src="cp%E8%8C%83%E4%BE%8B6.png" alt=""></p><p>``可以将多个文件一次复制进同一目录，注意最后一个一定是目录`</p><pre><code> cp ~/.bashrc ~/.bash_history /tmp  </code></pre></li><li><p>rm</p><p><img src="rm%E5%8F%82%E6%95%B0.png" alt="">  </p><pre><code>#在指令前加反斜线，可以忽略alias的指定选项，即删掉目录而不提示\rm -r /tmp/etc</code></pre><p><img src="rm%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BE%8B%E5%AD%90.png" alt=""></p></li></ul><ul><li><p>mv </p><p><img src="mv%E7%A4%BA%E4%BE%8B.png" alt=""></p></li></ul><p>取得路径的文件名称与目录名称</p><p><img src="basename%E4%B8%8Edirname.png" alt=""></p><p>文件内容查阅</p><ul><li><p>cat 由第一行开始显示文件内容</p><p><img src="cat.png" alt=""></p></li><li><p>tac 从最后一行开始显示，与cat显示方式相反</p></li><li><p>nl 显示的时候，顺道输出行号</p><p><img src="nl.png" alt=""></p></li><li><p>more 一页一页的显示文件内容</p><p><img src="more%E6%8C%89%E9%94%AE.png" alt=""></p></li><li><p>less与more类似，但是比more更好的是，它可以往前翻页</p><p><img src="less%E6%8C%89%E9%94%AE.png" alt=""></p></li><li><p>head 只看头几行</p><p><img src="head.png" alt=""></p></li><li><p>tail 只看尾巴几行</p><p><img src="tail.png" alt=""></p></li><li><p>od 以二进制的方式读取文件内容 （？ 命令od -t oCc /etc/issue存疑）</p><p><img src="od.png" alt=""></p></li><li><p>touch （选项中的时间可参照第6章ls）</p><p>默认不接参数，atime/ctime/mtime 为当前时间</p><p><img src="touch.png" alt=""></p></li></ul><p>文件与目录的默认权限与隐藏权限</p><p>文件默认权限 umask</p><ul><li>umask -S查看</li><li>文件默认权限为666，默认没有可执行权限，即-rw-rw-rw</li><li>目录默认权限为777，即drwxrwxrwx</li><li>若设置umask为002即输入命令 umask 002，则创建文件的默认权限为666-002=664，这个在Samaba Server和FTP Server当中很有用。</li><li>出于安全考虑，root的umask会拿掉比较多的属性，通常umask为022</li></ul><p>设置文件隐藏属性 chattr</p><p><img src="chattr.png" alt=""></p><p>显示文件隐藏属性 lsattr</p><p><img src="lsattr.png" alt=""></p><p>文件特殊权限：SUID,SGID,SBIT</p><ul><li><p>SUID</p><p>举例：用户可以自行更改密码，而密码文件的所有权为root</p><p>1.dmtsai 对于 /usr/bin/passwd 这个程序来说是具有 x 权限的， 表示<br>dmtsai 能执行 passwd；<br>2.passwd 的拥有者是 root 这个帐号；<br>3.dmtsai 执行 passwd 的过程中， 会“暂时” 获得 root 的权限；<br>4./etc/shadow 就可以被 dmtsai 所执行的 passwd 所修改</p><p><img src="suid.png" alt=""></p></li><li><p>SGID</p><p><strong>todo 待补充</strong></p></li><li><p>SBIT</p><p><strong>todo 待补充</strong></p></li></ul><p>file 文件名</p><p>​        可以简单获取文件信息</p><p>文件查找</p><ul><li><p>which 寻找可执行文件 </p><p>参数-a 可以列出所有PATH目录中的命令</p></li><li><p>find不常用 搜索硬盘的文件系统 速度慢<strong>todo 待补充</strong></p><p><img src="find.png" alt=""></p><p><img src="find_time.png" alt=""></p><p><img src="find3.png" alt=""></p></li><li><p>whereis 在某些特定的目录中寻找文件文件名</p><p><img src="whereis.png" alt=""></p></li><li><p>locate / updatedb 利用数据库搜索文件名</p><p><img src="locate.png" alt=""></p><p><img src="updatedb.png" alt=""></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 59</title>
      <link href="/2020/01/18/Effective%20Python%2059/"/>
      <url>/2020/01/18/Effective%20Python%2059/</url>
      
        <content type="html"><![CDATA[<ol><li><p>确认版本 python2 0r python3</p><p>python –version</p><p>python –version</p></li></ol><p>   import sys</p><p>   print(sys.version)</p><p>   print(sys.version_info)</p><ol start="2"><li><p>遵循PEP 8风格 （8号Python增强协议）</p><p>使用空格代替制表符</p><p>每行字符数不超过79</p><p>和语法相关的每一层缩进为4个空格</p><p><strong>占据多行的表达式，除首行之外其余各行应该在缩进的级别上再加4个空格</strong></p><p>文件中函数与类之间用两行隔开</p><p>同一个类，方法之间一行隔开</p><p>使用下标获取元素、调用函数或给键值参数赋值，不要加空格</p><p>函数、变量及属性应该用小写字母，单词之间用下划线</p><p>类和异常用每个首字母大写的方式表示，单词间用下划线</p><p>模块级别的常用采用全大写字母拼写，单词间用下划线</p><p>受保护的实例属性，用单个下划线开头</p><p>私有属性，两个下划线开头</p></li><li><p>了解bytes、str与unicode</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/01/18/Git/"/>
      <url>/2020/01/18/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li><p>增加用户信息</p><pre><code class="git">git config --global user.name &quot;John Doe&quot;git config --global user.email johndoe@example.com</code></pre><p><code>--local针对当前某仓库生效，优先级高于--global。就一个代码仓库而言，两个设置的效果一样</code></p></li><li><p>设置文本编辑器（默认使用操作系统默认的文本编辑器）</p><p>例如使用emacs</p><pre><code class="console">git config --global core.editor emacs</code></pre></li><li><p>检查配置信息</p><pre><code class="console">$ git config --listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto...$ git config user.name #查询某一项配置John Doe</code></pre></li><li><p>获取帮助</p><pre><code class="console">$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;$ git help config #获得 config 命令的手册</code></pre></li><li><p>建立Git仓库</p><p>a. 在现有目录下初始化仓库</p><pre><code class="console">$ git init# 添加文件并提交$ git add *.c #添加*.c文件 后面可以接多个文件或者文件夹$ git add LICENSE #添加license$ git commit -m &#39;initial project version&#39; #提交</code></pre><p>b. 从服务器clone一个现有的仓库</p><pre><code class="console">$ git clone https://github.com/libgit2/libgit2 $ git clone https://github.com/libgit2/libgit2 mylibgit #与上面一条命令区别的是:本地仓库的名字会变更为mylibgit</code></pre><p><em>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。</em></p></li><li><p>记录每次更新到仓库</p><p>你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪</p><ul><li>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。（ 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。）</li><li>其他均为未跟踪文件</li></ul></li><li><p>使用 Git 时文件的生命周期</p></li></ul><p><img src="lifecycle.png" alt="使用 Git 时文件的生命周期"></p><ul><li><p>检查当前文件状态</p><pre><code class="console">$ git statusOn branch masternothing to commit, working directory clean #此时表明工作目录已经干净了$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   README #只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</code></pre></li><li><p>暂存已修改文件</p><pre><code class="console"># 修改了一个已被跟踪（git add过的）的文件$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   READMEChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.md#文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</code></pre><pre><code>  现在让我们运行 git add 将&quot;CONTRIBUTING.md&quot;放到暂存区，然后再看看 git status 的输出：</code></pre><pre><code>$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)new file:   READMEmodified:   CONTRIBUTING.md</code></pre><p>​       怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本， 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：  </p><pre><code class="console">$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   README    modified:   CONTRIBUTING.md  </code></pre></li><li><p>状态简览</p><pre><code class="console">$ git status -s #等同于 git status --short M README #出现在右边的 M 表示该文件被修改了但是还没放入暂存区MM Rakefile #Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了 （该文件修改一次后 add了一次 又修改了一次）A  lib/git.rbM  lib/simplegit.rb #出现在靠左边的 M 表示该文件被修改了并放入了暂存区?? LICENSE.txt #未跟踪文件</code></pre></li><li><p>忽略文件</p></li></ul><p>  文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li><p>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</p></li><li><p>可以使用标准的 glob 模式匹配。</p></li><li><p>匹配模式可以以（<code>/</code>）开头防止递归。</p></li><li><p>匹配模式可以以（<code>/</code>）结尾指定目录。</p></li><li><p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</p><p>```console<br>$ cat .gitignore</p></li></ul><p>  *.[oa] #忽略所有以 .o 或 .a 结尾的文件<br>  *~ #忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 </p><pre><code>+ 查看已暂存和未暂存的修改  要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 `git diff`  ```console  $ git diff  diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md  index 8ebb991..643e24f 100644  --- a/CONTRIBUTING.md  +++ b/CONTRIBUTING.md  @@ -65,7 +65,8 @@ branch directly, things can get messy.   Please include a nice description of your changes when you submit your PR;   if we have to read the whole diff to figure out why you&#39;re contributing   in the first place, you&#39;re less likely to get feedback and have your change  -merged in.  +merged in. Also, split your changes into comprehensive chunks if your patch is  +longer than a dozen lines.   If you are starting to work on a particular area, feel free to submit a PR   that highlights your work in progress (and note in the PR title that it&#39;s</code></pre><p>  ​        此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><pre><code class="console">  #查看已暂存的将要添加到下次提交里的内容  $ git diff --staged   diff --git a/README b/README  new file mode 100644  index 0000000..03902a1  --- /dev/null  +++ b/README  @@ -0,0 +1 @@  +My Project</code></pre><ul><li><p>提交更新</p><pre><code class="console">$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README</code></pre></li><li><p>跳过使用暂存区域</p><p>跳过add这步，直接使用git commit -a -m “提交说明”，完成本次提交。</p><pre><code class="console">$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git commit -a -m &#39;added new benchmarks&#39;[master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre></li><li><p>移除文件</p><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：</p><pre><code class="console">$ git rm log/\*.log</code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><pre><code class="console">$ git rm \*~ #该命令为删除以 `~` 结尾的所有文件。</code></pre><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 </p></li></ul><p>  另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><pre><code class="console">  $ git rm --cached README</code></pre><ul><li><p>移动文件</p><pre><code class="console">$ git mv README.md README$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    renamed:    README.md -&gt; README</code></pre></li></ul><h1 id="todolist"><a href="#todolist" class="headerlink" title="todolist"></a>todolist</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>注重实效的程序员之快速参考指南</title>
      <link href="/2020/01/18/%E6%B3%A8%E9%87%8D%E5%AE%9E%E6%95%88%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/"/>
      <url>/2020/01/18/%E6%B3%A8%E9%87%8D%E5%AE%9E%E6%95%88%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考Tips</p></blockquote><ol><li><em>关心你的技艺 Care About Your Craft</em><br>如果你不在乎能否漂亮的开发出软件，你又为何要耗费生命去开发软件呢？</li></ol><ol start="2"><li><em>思考！你的工作 Think! About Your Work</em><br>关掉自动驾驶仪，接管操作。不断地批评和评估你的工作。</li></ol><ol start="3"><li><em>提供各种选择，不要找蹩脚的借口 Provide Options, Don’t Make Lame Excuses</em><br>要提供各种选择，而不是找借口。不要说事情做不到；说明能够做什么。</li></ol><ol start="4"><li><em>使质量成为需求问题 Make Quality a Requirements lssue</em><br>让你的用户参与确定项目真正的质量需求。</li></ol><ol start="5"><li><em>定期为你的知识资产投资 Invest Regularly in Your Knowledge Portfolio</em><br>让学习成为习惯。</li></ol><ol start="6"><li><em>批判地分析你读到的和听到的 Critically Analyze What You Read and Hear</em><br>不要被供应商、媒体炒作、或教条左右。要依照你自己的看法和你的项目的情况去对信息进行分析。</li></ol><ol start="7"><li><em>你说什么和你怎么说同样重要 It’s both What You Say and the Way You Say it</em><br>如果你不能有效地向他人传达你的了不起的想法，这些想法就毫无用处。</li></ol><ol start="8"><li><em>不要重复你自己 DRY - Don’t Repeat Yourself</em><br>系统中的每一项知识都必须具有单一、无歧义、权威的表示。</li></ol><ol start="9"><li><em>让复用变得容易 Make It Easy to Reuse</em><br>如果复用很容易，人们就会去复用。创造一个支持复用的环境。</li></ol><ol start="10"><li><em>消除无关事物之间的影响 Eliminate Effects Between Unrelated Things</em><br>设计自足、独立、并具有单一、良好定义的目的的组件。</li></ol><ol start="11"><li>不存在最终决策 There Are No Final Decisions<br>没有决策是浇铸在石头上的。相反，要把每项决策都视为是写在沙滩上的，并为变化做好计划。</li></ol><ol start="12"><li><p><em>用曳光弹找到目标 Use Tracer Bullets to Find the Target</em></p><p>曳光弹能通过试验各种事物并检查它们离目标有多远来让你追踪目标。</p></li></ol><ol start="13"><li><em>为了学习而制作原型 Prototype to Learn</em><br>原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。</li></ol><ol start="14"><li><em>靠近问题领域编程 Program Close to the Problem domain</em><br>用你的用户的语言进行设计和编码。</li></ol><ol start="15"><li><em>估算，以避免发生意外 Estimate to Avoid Surprises</em><br>在着手之前先进行估算。你将提前发现潜在的问题。</li></ol><ol start="16"><li><em>通过代码对进度表进行迭代 Iterate the Schedule with the Code</em><br>用你在进行实现时获得的经验提炼项目的时间标度。</li></ol><ol start="17"><li><em>用纯文本保存知识 Keep Knowledge in Plain Text</em><br>纯文本不会过时。它能够帮助你有效利用你的工作。并简化掉时和测试。</li></ol><ol start="18"><li><em>利用命令shell的力量 Use the Power of Command Shells</em><br>当图形用户界面无能为力时使用shell。</li></ol><ol start="19"><li><em>用好一种编辑器 Use a Single Editor Well</em><br>编辑器应该是你的手的延伸；确保你的编辑器是可配置、科扩展和可编程的。</li></ol><ol start="20"><li><em>总是使用源码控制 Always Use Source Code Control</em><br>源码控制是你的工作的时间机器–你能够回到过去。</li></ol><ol start="21"><li><em>要修正问题，而不是发出指责 Fix the Problem, Not the Blame</em><br>bug是你的过错还是别人的过错，并不是真的很有关系–它仍然是你的问题，它仍然需要修正。</li></ol><ol start="22"><li><em>调试时不要恐慌 Don’t Panic When Debuging</em><br>做一次深呼吸，思考什么可能是bug的原因。</li></ol><ol start="23"><li><em>“Select”没有问题 “Select” Isn’t Broken</em><br>在OS或编译器、甚或是第三方产品或库中很少发现bug。bug很可能在应用中。</li></ol><ol start="24"><li><em>不要假定，要证明 Don’t Assume It - Prove It</em><br>在实际环境中–使用真正的数据和辩解条件–证明你的假定。</li></ol><ol start="25"><li><p><em>学习一种文本操纵语言 Learn a Text Manipulation Language</em></p><p>你用每天的很大一部分时间处理文本，为什么不让计算机替你完成部分工作呢？</p></li></ol><ol start="26"><li><em>编写能编写代码的代码 Write Code That Writes Code</em><br>代码生成器能提高你的生产率，并有助于避免重复。</li></ol><ol start="27"><li><em>你不可能写出完美的软件 You Can’t Write Perfect Software</em><br>软件不可能完美。保护你的代码和用户，使它（他）们免于能够预见的错误。</li></ol><ol start="28"><li><em>通过合约进行设计 Design with Contracts</em><br>使用合约建立文档，并检验代码所做的事情正好是它声明要做的。</li></ol><ol start="29"><li><em>早崩溃 Crash Early</em><br>死程序造成的危害通常比有问题的程序要小得多。</li></ol><ol start="30"><li><em>用断言避免不可能发生的事情 Use Assertions to Prevent the Impossible</em><br>断言验证你的各种假定。在一个不确定的世界里，用断言保护你的代码。</li></ol><ol start="31"><li><em>将异常用于异常的问题 Use Exceptinos for Exceptional Problems</em><br>异常可能会遭受经典的意大利面条式代码的所有可读性和可维护性问题的折磨。将异常保留给异常的事物。</li></ol><ol start="32"><li><em>要有始有终 Finish What You Start</em><br>只要可能，分配某资源的例程或对象也应该负责解除其分配。</li></ol><ol start="33"><li><em>使模块之间的耦合减至最少 Minimize Coupling Between Modules</em><br>通过编写“羞怯的”代码并应用得墨忒耳法则来避免耦合。</li></ol><ol start="34"><li><em>要配置，不要集成 Configure, Don’t Integrate</em><br>要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现。</li></ol><ol start="35"><li><em>将抽象放进代码，细节放进元数据 Put Abstractions in Code, Details in Metadata</em><br>为一般情况编程，将细节放在被编译的代码库之外。</li></ol><ol start="36"><li><em>分析工作流，以改善并发性 Analyze Workflow to Imporve Concurrency</em><br>利用你的用户的工作流中的并发性。</li></ol><ol start="37"><li><em>用服务进行设计 Design Using Services</em><br>根据服务–独立的、在良好定义、一致的接口之后的兵法对象–进行设计。</li></ol><ol start="38"><li><p><em>总是为并发进行设计 Always Design for Concurrency</em></p><p>容许并发，你将会设计出更整洁、具有更少假定的接口。</p></li></ol><ol start="39"><li><p><em>使视图与模型分离 Separate Views from Models</em></p><p>要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性。</p></li></ol><ol start="40"><li><p><em>用黑板协调工作流 Use Blackboards to Coordinate Workflow</em></p><p>用黑板协调完全不同的事实和因素，同时又使各参与方保持独立和隔离。</p></li></ol><ol start="41"><li><p><em>不要靠巧合编程 Don’t Program by Coincidence</em></p><p>只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与有目的的计划混为一谈。</p></li></ol><ol start="42"><li><p><em>估算你的算法的阶 Estimate the Order of Your Algorithms</em></p><p>在你编写代码之前，先大致估算事情需要多长时间。</p></li></ol><ol start="43"><li><p><em>测试你的估算 Test Your Estimates</em></p><p>对算法的数学分析并不会告诉你每一件事情。在你的代码的目标环境中测定它的速度。</p></li></ol><ol start="44"><li><p><em>早重构，常重构 Refactor Early, Refactor Often</em></p><p>就和你会在华园里除草、并重新布置一样，在需要时对代码进行重写、重做和重新架构。要铲除问题的根源。</p></li></ol><ol start="45"><li><p><em>为测试而设计 Design to Test</em></p><p>在你还没有编写代码时就开始思考测试问题。</p></li></ol><ol start="46"><li><p><em>测试你的软件，否则你的用户就得测试 Test Your Software, or Your Users Will</em></p><p>无情地测试。不要让你的用户为你查找bug。</p></li></ol><ol start="47"><li><p><em>不要使用你不理解的向导代码 Don’t Use Wizard Code You Don’t Understand</em></p><p>想到可以生成大量代码。在你把它们合并进你的项目之前，确保你理解全部这些代码。</p></li></ol><ol start="48"><li><p><em>不要搜集需求–挖掘它们 Don’t Gather Requirements - Dig for Them</em></p><p>需求很少存在于表面上。它们深深地埋藏在层层假定、误解和政治手段的下面。</p></li></ol><ol start="49"><li><p><em>与用户一同工作，以像用户一样思考 Work with a User to Think Like a User</em></p><p>要了解系统实际上将如何被使用，这是最好的方法。</p></li></ol><ol start="50"><li><p><em>抽象比细节活得更长久 Abstractions Live Longer than Details</em></p><p>“投资”于抽象，而不是实现。</p></li></ol><ol start="51"><li><p><em>使用项目词汇表 Use a Project Glossary</em></p><p>创建并维护项目中使用的专用术语和词汇的单一信息源。</p></li></ol><ol start="52"><li><p><em>不要在盒子外面思考–要找到盒子 Don’t Think Outside the Box - Find the Box</em></p><p>在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“它必须以这种方式完成吗？ 它真的必须完成吗？”</p></li></ol><ol start="53"><li><p><em>等你准备好再开始 Start When You’re Ready</em></p><p>你的一生都在积累经验。不要忽视反复出现的疑惑。</p></li></ol><ol start="54"><li><p><em>对有些事情“做”胜于“描述” Some Things Are Better Done than Described</em></p><p>不要掉进规范的螺旋</p></li></ol><ol start="55"><li><p><em>不要做形式方法的奴隶 Don’t Be a Slave to Formal Methods</em></p><p>如果你没有把某项技术放进你的开发时间和能力的语境中，不要盲目地采用它。</p></li></ol><ol start="56"><li><p><em>昂贵的工具不一定能制作出更好的设计 Costly Tools Don’t Produce Better Disigns</em></p><p>小心供应商的炒作，行业教条，以及价格标签的诱惑。要根据工具的价值判断它们。</p></li></ol><ol start="57"><li><p><em>围绕功能组织团队 Organize Teams Around Fucntionality</em></p><p>不要把设计师与编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。</p></li></ol><ol start="58"><li><p><em>不要使用手工流程 Don’t Use Manual Procedures</em></p><p>shell脚本或批文件会一次次地以同一顺序执行同样的指令。</p></li></ol><ol start="59"><li><p><em>早测试，常测试，自动测试。 Test Early. Test Often. Test Automatically</em></p><p>与呆在书架上的测试计划相比，每次构建试运行的测试要有效得多。</p></li></ol><ol start="60"><li><p><em>要到通过全部测试，编码才算完成。 Coding Ain’t Done ‘Til All the Tests Run</em></p><p>就是这样。</p></li></ol><ol start="61"><li><p><em>通过“蓄意破坏”测试你的测试。 Use Saboteurs to Test Your Testing</em></p><p>在单独的软件副本上故意引入bug，以检验测试能够抓住它们。</p></li></ol><ol start="62"><li><p><em>测试状态覆盖，而不是代码覆盖 Test State Coverage, Not Code Coverage</em></p><p>确定并测试重要的程序状态。只是测试代码行是不够的。</p></li></ol><ol start="63"><li><em>一个bug只抓一次 Find Bugs Once</em><br>一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对其进行检查。</li></ol><ol start="64"><li><em>英语就是一种编程语言 English is Just a Programming Language</em><br>像你编写代码一样编写文档：遵守DRY原则、使用元数据、MVC、自动生成、等等。</li></ol><ol start="65"><li><em>把文档建在里面，不要栓在外面 Build Documentation In, Don’t Bolt It On</em><br>与代码分离的文档不太可能被修正和更新。</li></ol><ol start="66"><li>温和地超出用户的期望 Gently Exceed Your Users’ Expectations<br>要理解你的用户的期望，然后给他们的东西要多那么一点。</li></ol><ol start="67"><li><p><em>在你的作品上签名 Sign Your Work</em><br>过去时代的手艺人为能在他们作品上签名而自豪。你也应该如此。</p></li><li><p><em>做变化的催化剂 Be a Catalyst for Change</em><br>你不能强迫人们改变。相反，要向他们展示未来可能会怎样，并帮助他们参与对未来的创造。</p></li></ol><ol start="5"><li><em>不要容忍破窗户 Don’t Live with Broken Windows</em><br>当你看到糟糕的设计、错误的决策和糟糕的代码时，修正它们。</li></ol><ol start="6"><li><em>记住大图景 Remember the Big Picture</em><br>不要太过专注于细节，以至忘了查看你周围正在发生什么。</li></ol><blockquote><p>检查清单</p></blockquote><ol start="71"><li><em>要学习的语言</em><br>厌倦了C、C++和JAVA？试试CLOS、Dylan、Eiffel、Objectve C、Prolog、Smailltalk或TOM。它们每一种都有不同的能力和不同的“风味”。用其中的一种或多种语言在家里开发一个小项目。</li></ol><ol start="72"><li><em>WISDOM离合诗</em><br>What do you want them to learn? 你想让他们学到什么？<br>What is their interest in what you’ve got to say? 他们对你讲的什么感兴趣？<br>How sophisticated are they? 他们有多富有经验？<br>How much detail do they want? 他们想要多少细节？<br>Whom do you want to own the information? 你想要让谁拥有这些信息？<br>How can you motivate them to listen to you? 你如何促使他们听你说话？</li></ol><ol start="73"><li><em>怎样维持正交性</em><br>设计独立、良好定义的组件。<br>使你的代码保持解耦。<br>避免使用全局数据。<br>重构相似的函数。</li></ol><ol start="74"><li><em>应制作原型的事物</em><br>架构<br>已有系统中的新功能<br>外部数据的结构或内容<br>第三方工具或组件<br>性能问题<br>用户界面设计</li></ol><ol start="75"><li><em>架构问题</em><br>责任是否得到了良好定义？<br>写作是否得到了良好定义？<br>耦合是否得以最小化？<br>你能否确定潜在的重复？<br>接口定义和各项约束是否可接受？<br>模块能否在需要时访问所需数据？</li></ol><ol start="76"><li><p><em>调试检查清单</em><br>正在报告的问题是底层bug的直接结果，还是只是症状？<br>bug真的在编译器里？在OS里？或者是在你的代码里？<br>如果你向同事详细解释这个问题，你会说什么？<br>如果可疑代码通过了单元测试，测试是否足够完整？如果你用该数据运行单元测试，会发生什么？</p><p>​        造成这个bug的条件是否存在于系统中的其它任何地方？</p></li></ol><ol start="77"><li><em>函数的得墨忒耳法则</em><br>某个对象的方法应该只调用属于以下情况的方法：<br>它自身<br>传入的任何参数<br>它创建的对象<br>组件对象</li></ol><ol start="78"><li><em>怎样深思熟虑地编程</em><br>总是意识到你在做什么。<br>不要盲目地编程。<br>按照计划行事。<br>依靠可靠的事物。<br>为你的假定建立文档。<br>不要只是测试你的代码，还要测试你的假定。<br>维护的工作划分优先级。<br>不要做历史的奴隶。</li></ol><ol start="79"><li><em>何时进行重构</em><br>你发现了对DRY原则的违反。<br>你发现事物可以更为正交。<br>你的知识扩展了。<br>需求演变了。<br>你需要改善性能。</li></ol><ol start="80"><li><em>劈开戈尔迪斯结</em><br>在解决不可能解决的问题时，问问你自己：<br>有更容易的方法吗？<br>我是在解决正确的问题吗？<br>这件事情为什么是一个问题？<br>是什么使它如此难以解决？<br>它必须以这种方式完成吗？<br>它真的必须完成吗？</li></ol><ol start="81"><li><p><em>测试的各个方面</em></p><p>单元测试<br>集成测试<br>炎症和校验<br>资源耗尽、错误及恢复<br>性能测试<br>可用性测试<br>对测试自身进行测试</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>note</title>
      <link href="/2020/01/18/note/"/>
      <url>/2020/01/18/note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python</p></blockquote><ul><li>列表拉成一列</li></ul><pre><code class="python">from compiler.ast import flattenlistA = flatten([mulitlist]) #mulitlist可以为多层嵌套列表</code></pre><blockquote><p>Git</p></blockquote><ul><li><p>删除上次提交，使用reset命令</p><p>HEAD是指向最新的提交，上一次提交是HEAD^,上上次是HEAD^^,也可以写成HEAD～2 ,依次类推。</p></li></ul><pre><code>git reset --hard HEAD^git push origin master -f</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/2020/01/18/README/"/>
      <url>/2020/01/18/README/</url>
      
        <content type="html"><![CDATA[<h1 id="StudyNotes"><a href="#StudyNotes" class="headerlink" title="StudyNotes"></a>StudyNotes</h1><blockquote><p><a href="C_C++">C/C++</a></p><p><a href="Linux">Linux</a></p><p><a href="python">python</a></p><p><a href="Web基础">Web基础</a></p><p><a href="代码管理">代码管理</a></p><p><a href="数据库">数据库</a></p><p><a href="网络基础">网络基础</a></p><p><a href="小技巧">小技巧</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/18/hello-world/"/>
      <url>/2020/01/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
